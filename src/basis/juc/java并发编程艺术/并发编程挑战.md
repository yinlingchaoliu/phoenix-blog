---
title: 并发编程挑战
date: 2024-03-25 22:02:09
category:
  - java并发编程艺术
tag:
  - archive
---
#### 影响并发原因
```
1、线程创建和上下文切换开销
2、死锁
3、硬件资源
```

Lmbench3  上下文切换时长
vmstat 上下文切换次数
vmstat  1
cs 表示次数

####  1、减少上下文切换

* 1、无锁并发编程：多线程竞争锁时，会引起上下文切换

* 2、CAS算法：java atomic包 CAS算法（Compare And Swap），出现BAB问题，用版本号解决

*3、最少使用线程

*4、使用协程


`减少WAITTING线程，来减少上下文切换`
```shell
//查看进程
ps -ef | grep  keyword

//jstack dump线程信息
jstack   pid  > dump.txt

//查看当前线程状态
grep  java.lang.Thread.State  dump.txt | awk '{ print $2$3$4$5  }' | sort | uniq -c 

打印>>
   2 BLOCKED(onobjectmonitor)
   8 RUNNABLE
   2 WAITING(onobjectmonitor)
```

#### 2、死锁

避免死锁方法
1、避免一个线程获取多个锁
2、避免一个线程在所内同时占有多个资源，尽量保证每个锁只占用一个资源
3、尝试使用定时锁 lock.tryLock(timeout)
4、加锁解锁在一起

```
//测试死锁
public class DeadLockDemo {

    private Object A = new Object();
    private Object B = new Object();

    private Runnable run1 = new Runnable() {
        @Override
        public void run() {
            synchronized (A){
                try {
                    Thread.sleep( 2000 );
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                synchronized (B){
                    System.out.println("1");
                }
            }
        }
    };

    private Runnable run2 = new Runnable() {
        @Override
        public void run() {

            synchronized (B){
                synchronized (A){
                    System.out.println("2");
                }
            }
        }
    };

    public static void main(String[] args){
        new DeadLockDemo().deadLock();
    }
    
    private void deadLock(){
        new Thread( run1 ).start();
        new Thread( run2 ).start();
    }

}
```

####3、资源限制
根据资源限制情况，调整并发度


####juc编程源码
https://github.com/yinlingchaoliu/juc
tag  "dead lock"
